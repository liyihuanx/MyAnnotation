package liyihuan.app.android.lib_compiler

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import liyihuan.app.android.lib_annotation.DownLoad
import liyihuan.app.android.lib_compiler.types.AptContext
import liyihuan.app.android.lib_compiler.types.javaToKotlinType
import liyihuan.app.android.lib_compiler.types.packageName
import liyihuan.app.android.lib_compiler.types.simpleName
import java.io.File
import java.io.IOException
import java.lang.Exception
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.PackageElement
import javax.lang.model.element.TypeElement

/**
 * @ClassName: DowloadProcessor
 * @Description: java类作用描述
 * @Author: liyihuan
 * @Date: 2022/1/17 21:22
 */
@AutoService(Processor::class)
// 允许/支持的注解类型，让注解处理器处理
@SupportedAnnotationTypes(ANNOTATION_NAME)
// 指定JDK编译版本
@SupportedSourceVersion(SourceVersion.RELEASE_8)
// 注解处理器接收的参数
@SupportedOptions(KAPT_KOTLIN_GENERATED_OPTION_NAME,APT_PACKAGE)
class DownloadProcessor : AbstractProcessor() {
    private var clazzName = ""
    private var packageName = ""
    private var clazz : TypeElement? = null

    override fun init(processingEnv: ProcessingEnvironment) {
        super.init(processingEnv)
        AptContext.init(processingEnv)
        AptContext.note(" 注解 init")
    }

    /**
     * 存放使用download注解的类，和该类使用了的的注解
     * [MainActivity,Map<annotation,fun>]
     */
    private val downLoadTypeMap = HashMap<String, HashMap<String, String>>()


    override fun process(annotations: MutableSet<out TypeElement>, env: RoundEnvironment): Boolean {
        if (annotations.isEmpty()) {
            AptContext.note("没有使用过注解")
            return false
        }

        // 收集
        handleAnnotation(env, DownLoad.onPre::class.java)
        handleAnnotation(env, DownLoad.onStart::class.java)
        handleAnnotation(env, DownLoad.onComplete::class.java)
        handleAnnotation(env, DownLoad.onSuc::class.java)
        handleAnnotation(env, DownLoad.onFail::class.java)

        // build 文件构建
        buildClass()
        return true
    }


    private fun buildClass() {
        val realClazzName = "$clazzName$POSIX"
        // 文件
        val fileBuilder = FileSpec.builder(packageName, realClazzName)
        // 类
        val typeBuilder = TypeSpec.classBuilder(realClazzName)
            .addModifiers(KModifier.PUBLIC)
            .addModifiers(KModifier.OPEN)
            .superclass(SUPER_INTERFACE)
            .addKdoc("This file is generated by kapt, please do not edit this file")




        addProperty(typeBuilder)

        // 加注解的方法和setListener
        addFunction(typeBuilder)



        fileBuilder.addType(typeBuilder.build())
        val fileSpec = fileBuilder.build()
        val file = getRootFile()
        fileSpec.writeTo(file)
    }

    /**
     * 添加参数
     */
    private fun addProperty(typeBuilder: TypeSpec.Builder){
        // 类的参数变量
        val parameter = PropertySpec.builder("activityObj", clazz!!.javaToKotlinType().asNullable())
            .mutable(true)
            .initializer("null")
            .build()
        typeBuilder.addProperty(parameter)
    }


    /**
     * 添加方法
     */
    private fun addFunction(typeBuilder: TypeSpec.Builder) {
        // 拿到接口的方法 --> 要和和注解的方法名字一致
//        val clazz = Class.forName(I_DOWNLOAD_PATH)
//        clazz.declaredMethods.forEach {
//            AptContext.note("方法名-> ${it.name}")
//        }

//        val flux = FunSpec.constructorBuilder()
//            .addStatement("%T.register(%S,this)", DOWNLOAD_MANAGER, clazzName)
//            .build()
//
//        typeBuilder.primaryConstructor(flux)

        val commonFun = FunSpec.builder("setActivity")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("activity", ACTIVITY.asNullable())
            .addStatement("this.activityObj = (activity as %T)",clazz!!.javaToKotlinType())

        typeBuilder.addFunction(commonFun.build())


        downLoadTypeMap[clazzName]?.forEach {
            val fun1 = FunSpec.builder(it.key)
                .addModifiers(KModifier.OVERRIDE)
                .addStatement("activityObj?.%N()",it.value)

            typeBuilder.addFunction(fun1.build())

        }
    }

    /**
     * 创建文件
     */
    private fun getRootFile(): File {
        val file = File(getGeneratedSourcesRoot())
        file.mkdir()
        return file
    }

    /**
     * 获取kotlin保存的路径
     */
    private fun getGeneratedSourcesRoot(): String {
        val generatedSourcesRoot: String =
            processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty()
        if (generatedSourcesRoot.isEmpty()) {
            AptContext.error("Can't find the target directory for generated Kotlin files.")
        }
        return generatedSourcesRoot
    }

    /**
     * VariableElement 一般代表成员变量
     * ExecutableElement 一般代表类中的方法
     * TypeElement 一般代表代表类
     * PackageElement 一般代表Package
     *
     * 获取注解标注的类信息
     */
    private fun handleAnnotation(
        env: RoundEnvironment,
        annotationClazz: Class<out Annotation>,
    ) {
        env.getElementsAnnotatedWith(annotationClazz).forEach {

            clazz = it.enclosingElement as TypeElement

            // 拿到使用注解的类名
            if (clazzName.isEmpty()){
                clazzName = (it.enclosingElement as TypeElement).simpleName()
            }
            // 拿到报名
            if (packageName.isEmpty()){
                packageName = (it.enclosingElement as TypeElement).packageName()
            }

            // 拿到使用的方法名
            val methodName = (it as ExecutableElement).simpleName
            AptContext.note("$packageName --> ${clazzName}类 使用了注解 方法为$methodName")

            // 查看该类，使用的注解和对应的方法
            var downloadType = downLoadTypeMap[clazzName]
            if (downloadType.isNullOrEmpty()) {
                downloadType = HashMap()
                downLoadTypeMap[clazzName] = downloadType
            }

            var methodMap = downloadType[annotationClazz.simpleName.toString()]
            if (methodMap.isNullOrEmpty()) {
                downloadType[annotationClazz.simpleName.toString()] = methodName.toString()
            }


        }
    }

}