package liyihuan.app.android.lib_compiler

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import liyihuan.app.android.lib_annotation.DownLoad
import liyihuan.app.android.lib_compiler.types.AptContext
import liyihuan.app.android.lib_compiler.types.packageName
import liyihuan.app.android.lib_compiler.types.simpleName
import java.io.File
import java.io.IOException
import java.lang.Exception
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.PackageElement
import javax.lang.model.element.TypeElement

/**
 * @ClassName: DowloadProcessor
 * @Description: java类作用描述
 * @Author: liyihuan
 * @Date: 2022/1/17 21:22
 */
@AutoService(Processor::class)
// 允许/支持的注解类型，让注解处理器处理
@SupportedAnnotationTypes(ANNOTATION_NAME)
// 指定JDK编译版本
@SupportedSourceVersion(SourceVersion.RELEASE_8)
// 注解处理器接收的参数
@SupportedOptions(KAPT_KOTLIN_GENERATED_OPTION_NAME,APT_PACKAGE)
class DownloadProcessor : AbstractProcessor() {
    private var clazzName = ""
    private var packageName = ""

    override fun init(processingEnv: ProcessingEnvironment) {
        super.init(processingEnv)
        AptContext.init(processingEnv)
        AptContext.note(" 注解 init")
    }

    /**
     * 存放使用download注解的类，和该类使用了的的注解
     * [MainActivity,Map<annotation,fun>]
     */
    private val downLoadTypeMap = HashMap<String, HashMap<String, String>>()


    override fun process(annotations: MutableSet<out TypeElement>, env: RoundEnvironment): Boolean {
        if (annotations.isEmpty()) {
            AptContext.note("没有使用过注解")
            return false
        }

        // 收集
        handleAnnotation(env, DownLoad.onPre::class.java)
        handleAnnotation(env, DownLoad.onStart::class.java)
        handleAnnotation(env, DownLoad.onComplete::class.java)

        // build 构建
        buildClass()
        return true
    }


    private fun buildClass() {
        val realClazzName = "$clazzName$POSIX"
        // 文件
        val fileBuilder = FileSpec.builder(packageName, realClazzName)
        // 类
        val typeBuilder = TypeSpec.classBuilder(realClazzName)
            .addModifiers(KModifier.PUBLIC)
            .addModifiers(KModifier.OPEN)
            .addKdoc("This file is generated by kapt, please do not edit this file")
            .build()
        fileBuilder.addType(typeBuilder)


        val fileSpec = fileBuilder.build()
        val file = getRootFile()
        fileSpec.writeTo(file)

    }

    private fun getRootFile(): File {
        val file = File(getGeneratedSourcesRoot())
        file.mkdir()
        return file
    }

    private fun getGeneratedSourcesRoot(): String {
        AptContext.note("module：${processingEnv.options[APT_PACKAGE]}")

        val generatedSourcesRoot: String =
            processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty()
        if (generatedSourcesRoot.isEmpty()) {
            AptContext.error("Can't find the target directory for generated Kotlin files.")
        }
        return generatedSourcesRoot
    }

    /**
     * VariableElement 一般代表成员变量
     * ExecutableElement 一般代表类中的方法
     * TypeElement 一般代表代表类
     * PackageElement 一般代表Package
     */
    private fun handleAnnotation(
        env: RoundEnvironment,
        annotationClazz: Class<out Annotation>,
    ) {
        env.getElementsAnnotatedWith(annotationClazz).forEach {

            // 拿到使用注解的类名
            if (clazzName.isEmpty()){
                clazzName = (it.enclosingElement as TypeElement).simpleName()
            }

            if (packageName.isEmpty()){
                packageName = (it.enclosingElement as TypeElement).packageName()
            }

            // 拿到使用的方法名
            val methodName = (it as ExecutableElement).simpleName
//            包名: ${clazzName.qualifiedName.}
            AptContext.note("$packageName --> ${clazzName}类 使用了注解 方法为$methodName")

            // 查看该类使用了注解的方法
//            var downloadInfo = downLoadTypeMap[clazzName.toString()]
//            if (downloadInfo == null) {
//                downloadInfo = DownLoadInfo(methodName.toString(), annotationClazz.toString())
//            }

            // 查看该类，使用的注解和对应的方法
            var downloadType = downLoadTypeMap[clazzName.toString()]
            if (downloadType.isNullOrEmpty()) {
                downloadType = HashMap()
                downLoadTypeMap[clazzName] = downloadType
            }

            var methodMap = downloadType[annotationClazz.simpleName.toString()]
            if (methodMap.isNullOrEmpty()) {
                downloadType[annotationClazz.simpleName.toString()] = methodName.toString()
            }
//          // 收集完的结果
//          {MainActivity={onStart=onNewStart, onComplete=onComplete, onPre=onPre}}
//            AptContext.note("HashMap： $downLoadTypeMap")


        }
    }

}